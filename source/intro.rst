====================
 イントロダクション
====================

イントロでは、Jubatusと分散処理の関係と、機械学習の簡単な説明をを行います。
より詳しい機械学習の説明とJubatusの説明は、参考文献を参照してください。


Jubatusと分散
-------------------

Jubatusは、2011年秋に公開されてまもなく二年になります。
Jubatusが開発した当初から目指していた世界は、
「さまざまな所で大量のデータが生成され続けている。これらのデータをリアルタイムに学習しながらリアルタイムに分析を行う」というものです。この世界を実現するために、「オンライン機械学習」を「分散処理」する、という仕組みを考えました。前回のハンズオンでは主に「オンライン機械学習」にフォーカスを当てた説明を行いました。
今回のハンズオンでは、「分散処理」にフォーカスをあてて説明します。

Jubatusは、そもそもなぜ分散するのでしょうか？
Jubatusは先に述べた通り、「さまざまな所で大量のデータが生成され続けている。これらのデータをリアルタイムに学習しながらリアルタイムに分析を行う」を実現します。
しかし一般的な話として、一台で処理できる単位時間あたりの処理量は限られているため、一台でリアルタイムに処理できるデータの量は限られています。
また、データは生成され続けているため、データを分析し続ける必要があります。そのため、分析しているノードで障害が発生したりしても正しく動作し続ける必要があります。
これらに対処するために、クラスタ構成を組んで、スループットを上げたり、冗長構成を取って、耐障害性を高めたりします。

しかし、機械学習や分散処理をよくご存知のかたは疑問に思うかもしれません。
これらノード間 or 機械学習の演算 の同期をどのように実現しているのだろう、と。

Jubatusは ``MIX`` という独自の仕組みを用いて、これらを解決しています。

MIXとはなにか
----------------------

Jubatusにおいてサーバ同士が、緩やかなモデルの共有を行う仕組みのことを ``MIX`` といいます。

本章ではこの「緩やかな」を知るために、0.5.0から利用できる ``jubanearest_neighbor`` のアルゴリズムと、分散方式、及びそのMIXについて紹介します。


``jubanearest_neighbor`` とは、近傍探索を行うアルゴリズムを実装したサーバです。
近傍探索とは、特徴ベクトルで表現される空間に何かしらの距離を定義し、その距離が近いものを探す、というタスクです。
この近傍探索は、推薦、異常検知、クラスタリングなど様々なアルゴリズムの基盤となる手法で、 実は ``jubarecommender`` や ``jubaanomaly`` の内部実装にも使われています。
点と点との距離は距離の公理さえ満たしていればよく、なにかしら数式さえ構成することができれば簡単に計算することが可能です。
しかし、ある点からの距離が近い点を探そうとすると、O(n^2)の計算量がかかってしまいます。これはとても重たい処理です。そのため多くの近傍探索アルゴリズムでは、確率的に近傍を見つけることができる処理を実装しています。ここでは、これを実現するLocal Sensitive Hashing(LSH)というアルゴリズムを紹介します。LSHとはその名の通り、近いところは近くなるように設計されたハッシュ関数です。これを幾つか組み合わせることで、近い点を高い確率で検出することができます。詳しくは、[1] などを参照してください。
ここで知っていて欲しいのは、それぞれの点はそのハッシュ値のリストで表現することができて、そのハッシュ値のリストを使えば、O(n)の演算で近傍などを探すことができる、ということです。

Jubatusは、クライアントコードから分散処理を意識させないようにするためにProxyというプロセスを用意しています。Proxyは当初、Zookeeperとのやりとりを代行するプロセスとして、Keeperという名前が付けられていましたが、Zookeeperとのやりとりだけではなく、分散処理そのものを代行して行う、プロキシプロセスであるということで、変更が加えられました。

JubatusのProxyはクライアントにたいして、Serverのように振る舞います。NAMEで指定された機械学習タスクごとにServerが登録されています。Proxyは、クライアントからのクエリを受けると、そのServerのリストから適切なサーバを適切なアルゴリズムを使って選び、クエリーを代行します。
これにより、クライアントを使ってアプリケーションを開発する人は、裏で何台のサーバーが動作しているのか気にすることなくアプリケーションロジックの開発に専念できるようになります。
``jubanearest_neighbor_proxy`` は、この振り分けロジックに ``ID`` をキーとするコンシステントハッシングを利用しています。
これにより台数を増やせば増やすほど、単位時間あたりの学習量と分析量をスケールアウトさせることが出来ます。

コンシステントハッシングを使ってデータを割り振って別々に学習しているので、このままでは、別のサーバで学習した結果、 ``jubanearest_neighbor`` の場合は近傍 を利用することが出来ません。
そこで行うのが、MIXです。 近傍探索におけるMIXとは、それぞれのハッシュ値のリストを共有することです。お互いに持っていないデータや古いデータを見つけて上書きするだけです。
``MIX`` は、指定した個数の学習、もしくは最後にMIXしてからの指定時間が経過したときに起こります。 つまりその間は クラスタ全体としてみると正しい結果が得られない可能性があります。
このような状況を「穏やかな」モデルの共有、と表現し、これらを実現する仕組みを ``MIX`` と読んでいます。

MIXはアルゴリズムごとに手法が異なります。そのため精度は、タスクの種類、MIXの頻度、データ入力のタイミングなどにより変化します。


.. note::

   jubaclassifierにおけるMIXは、MIXのタイミングとデータ入力のタイミングによって、入力されたデータが失われる（モデルに反映されない）ことがあります。

